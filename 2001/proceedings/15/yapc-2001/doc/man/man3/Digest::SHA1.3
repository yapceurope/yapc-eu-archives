.\" Automatically generated by Pod::Man version 1.02
.\" Wed Jul 11 21:56:00 2001
.\"
.\" Standard preamble:
.\" ======================================================================
.de Sh \" Subsection heading
.br
.if t .Sp
.ne 5
.PP
\fB\\$1\fR
.PP
..
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Ip \" List item
.br
.ie \\n(.$>=3 .ne \\$3
.el .ne 3
.IP "\\$1" \\$2
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R

.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  | will give a
.\" real vertical bar.  \*(C+ will give a nicer C++.  Capital omega is used
.\" to do unbreakable dashes and therefore won't be available.  \*(C` and
.\" \*(C' expand to `' in nroff, nothing in troff, for use with C<>
.tr \(*W-|\(bv\*(Tr
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` `
.    ds C' '
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
'br\}
.\"
.\" If the F register is turned on, we'll generate index entries on stderr
.\" for titles (.TH), headers (.SH), subsections (.Sh), items (.Ip), and
.\" index entries marked with X<> in POD.  Of course, you'll have to process
.\" the output yourself in some meaningful fashion.
.if \nF \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
.    .
.    nr % 0
.    rr F
.\}
.\"
.\" For nroff, turn off justification.  Always turn off hyphenation; it
.\" makes way too many mistakes in technical documents.
.hy 0
.if n .na
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.bd B 3
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ======================================================================
.\"
.IX Title "SHA1 3"
.TH SHA1 3 "perl v5.6.0" "2000-09-18" "User Contributed Perl Documentation"
.UC
.SH "NAME"
Digest::SHA1 \- Perl interface to the \s-1SHA-1\s0 Algorithm
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 2
\& # Functional style
\& use Digest::SHA1  qw(sha1 sha1_hex sha1_base64);
.Ve
.Vb 3
\& $digest = sha1($data);
\& $digest = sha1_hex($data);
\& $digest = sha1_base64($data);
.Ve
.Vb 2
\& # OO style
\& use Digest::SHA1;
.Ve
.Vb 1
\& $ctx = Digest::SHA1->new;
.Ve
.Vb 2
\& $ctx->add($data);
\& $ctx->addfile(*FILE);
.Ve
.Vb 3
\& $digest = $ctx->digest;
\& $digest = $ctx->hexdigest;
\& $digest = $ctx->b64digest;
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
The \f(CW\*(C`Digest::SHA1\*(C'\fR module allows you to use the \s-1NIST\s0 \s-1SHA-1\s0 message
digest algorithm from within Perl programs.  The algorithm takes as
input a message of arbitrary length and produces as output a 160\-bit
\&\*(L"fingerprint\*(R" or \*(L"message digest\*(R" of the input.
.PP
The \f(CW\*(C`Digest::SHA1\*(C'\fR module provide a procedural interface for simple
use, as well as an object oriented interface that can handle messages
of arbitrary length and which can read files directly.
.PP
A binary digest will be 20 bytes long.  A hex digest will be 40
characters long.  A base64 digest will be 27 characters long.
.SH "FUNCTIONS"
.IX Header "FUNCTIONS"
The following functions can be exported from the \f(CW\*(C`Digest::SHA1\*(C'\fR
module.  No functions are exported by default.
.Ip "sha1($data,...)" 4
.IX Item "sha1($data,...)"
This function will concatenate all arguments, calculate the \s-1SHA-1\s0
digest of this \*(L"message\*(R", and return it in binary form.
.Ip "sha1_hex($data,...)" 4
.IX Item "sha1_hex($data,...)"
Same as \fIsha1()\fR, but will return the digest in hexadecimal form.
.Ip "sha1_base64($data,...)" 4
.IX Item "sha1_base64($data,...)"
Same as \fIsha1()\fR, but will return the digest as a base64 encoded string.
.SH "METHODS"
.IX Header "METHODS"
The \f(CW\*(C`Digest::SHA1\*(C'\fR module provide the standard \f(CW\*(C`Digest\*(C'\fR OO-interface.
The constructor looks like this:
.Ip "$sha1 = Digest->new('\s-1SHA-1\s0')" 4
.IX Item "$sha1 = Digest->new('SHA-1')"
.Ip "$sha1 = Digest::SHA1\->new" 4
.IX Item "$sha1 = Digest::SHA1->new"
The constructor returns a new \f(CW\*(C`Digest::SHA1\*(C'\fR object which encapsulate
the state of the \s-1SHA-1\s0 message-digest algorithm.  You can add data to
the object and finally ask for the digest using the methods described
in the Digest manpage.
.SH "SEE ALSO"
.IX Header "SEE ALSO"
the Digest manpage, the Digest::HMAC_SHA1 manpage, the Digest::MD5 manpage
.PP
http://www.itl.nist.gov/fipspubs/fip180\-1.htm
.SH "COPYRIGHT"
.IX Header "COPYRIGHT"
This library is free software; you can redistribute it and/or
modify it under the same terms as Perl itself.
.PP
.Vb 2
\& Copyright 1999-2000 Gisle Aas.
\& Copyright 1997 Uwe Hollerbach.
.Ve
.SH "AUTHORS"
.IX Header "AUTHORS"
Peter C. Gutmann,
Uwe Hollerbach <uh@alumni.caltech.edu>,
Gisle Aas <gisle@aas.no>
